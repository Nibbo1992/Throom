<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>D&D Session Notes</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Inter', sans-serif;
      transition: background-color 0.4s, color 0.4s;
    }
    /* INCREASED NOTES AREA HEIGHT by reducing the fixed offset from 300px to 250px */
    #notes-area, #preview {
      height: calc(100vh - 250px);
      overflow-y: auto; /* Enable scrolling for long content */
      resize: none;
    }
    .text-sm { font-size: 0.875rem; }
    .text-base { font-size: 1rem; }
    /* Dark Mode Styles */
    .dark-mode {
      background-color: #1e1e1e !important;
      color: #f1f1f1 !important;
    }
    .dark-mode textarea,
    .dark-mode #preview {
      background-color: #2a2a2a !important;
      color: #f1f1f1 !important;
      border-color: #444 !important;
    }
    /* Fix for prose content in dark mode */
    .dark-mode #preview.prose h1, .dark-mode #preview.prose h2, .dark-mode #preview.prose h3 {
        color: #ddd !important;
    }
    .dark-mode #preview.prose {
        color: #f1f1f1;
    }
    /* Style for the index area in preview */
    .index-panel {
        background-color: #f9fafb;
        border: 1px solid #e5e7eb;
    }
    .dark-mode .index-panel {
        background-color: #333;
        border-color: #444;
    }
    .dark-mode .index-panel h4 {
        color: #ddd;
    }
    /* Styling for the target tag after jumping */
    .scroll-target {
        scroll-margin-top: 1.5rem; /* Offset for sticky headers if they existed, or just a little padding */
    }
    /* Custom styling for dark mode button group borders to ensure visibility */
    .dark-mode .header-btn {
        border-color: #374151 !important; /* Darker border for separation */
    }
    .dark-mode .toolbar-btn, .dark-mode #heading-select {
        border-color: #3f3f46 !important;
    }
    .dark-mode #clear-btn {
        border-color: #991b1b !important; 
    }
  </style>
</head>
<body class="bg-stone-100 text-slate-800">
    
  <div class="container mx-auto p-4 max-w-5xl">
    <!-- REDUCED HEADER MARGIN FROM mb-4 to mb-2 -->
    <header class="text-center mb-2">
      <h1 class="text-2xl md:text-3xl font-bold mb-0">Session Notes: The Stonebreaker's Journal</h1>
      <p id="status-message" class="text-slate-600 dark-mode:text-slate-400 text-xs mb-3">Notes are automatically saved to your browser as you type.</p>
      <!-- BUTTON GROUP: Removed gap-[1px], added overflow-hidden, rounded-lg, and shadow-md to container -->
      <div class="flex flex-wrap justify-center mb-3 text-white shadow-md rounded-lg overflow-hidden">
        <!-- Buttons now use border-r to separate, creating a continuous block effect -->
        <button id="save-btn" class="header-btn px-3 py-2 text-sm bg-slate-700 hover:bg-slate-800 border-r border-slate-500/50">💾 <span class="hidden sm:inline">Save</span></button>
        <button id="download-btn" class="header-btn px-3 py-2 text-sm bg-slate-700 hover:bg-slate-800 border-r border-slate-500/50">⬇️ <span class="hidden sm:inline">Download</span></button>
        <button id="timestamp-btn" class="header-btn px-3 py-2 text-sm bg-slate-700 hover:bg-slate-800 border-r border-slate-500/50">🕒 <span class="hidden sm:inline">Timestamp</span></button>
        <!-- Clear button is red and needs its own specific border color for the group effect -->
        <button id="clear-btn" class="header-btn px-3 py-2 text-sm bg-red-600 hover:bg-red-700 border-r border-red-500/50">❌ <span class="hidden sm:inline">Clear</span></button>
        <button id="preview-toggle" class="header-btn px-3 py-2 text-sm bg-slate-700 hover:bg-slate-800 border-r border-slate-500/50">👁️ <span class="hidden sm:inline">Preview</span></button>
        <!-- Dark Mode button is the last in the group, no right border needed -->
        <button id="dark-toggle" class="header-btn px-3 py-2 text-sm bg-slate-700 hover:bg-slate-800">🌙 <span class="hidden sm:inline">Dark Mode</span></button>
      </div>
    </header>

    <div class="bg-white p-4 rounded-lg shadow-xl border border-slate-200">
      <div id="editor-container">
        <!-- TOOLBAR GROUP: Removed gap-[1px], added shadow-sm, rounded, and overflow-hidden -->
        <div id="toolbar" class="flex flex-wrap mb-2 shadow-sm rounded overflow-hidden">
          <!-- Buttons now use border-r to separate and are slightly larger for better touch targets -->
          <button data-format="bold" title="Bold (Ctrl/Cmd+B)" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300">B</button>
          <button data-format="italic" title="Italic (Ctrl/Cmd+I)" class="toolbar-btn px-2 py-1 text-sm italic bg-slate-200 hover:bg-slate-300 border-r border-slate-300">I</button>
          <button data-format="underline" title="Underline" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300">U</button>
          <button data-format="strike" title="Strikethrough" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300">S</button>
          <select id="heading-select" class="px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300 cursor-pointer">
            <option value="">Normal</option>
            <option value="h1">H1</option>
            <option value="h2">H2</option>
            <option value="h3">H3</option>
          </select>
          <button data-format="list" title="List" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300">•</button> 
          <button data-format="quote" title="Quote" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300">❝</button>
          <button data-format="code" title="Code Inline" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 border-r border-slate-300">{ }</button>
          <!-- Divider button is the last in the group -->
          <button data-format="divider" title="Divider" class="toolbar-btn px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300">―</button>
        </div>
        <textarea id="notes-area" class="w-full p-4 border border-slate-300 rounded-lg focus:ring-slate-500 focus:border-slate-500 text-slate-700 text-base" placeholder="Start logging your adventure here...\n\n-- Session [Date] --\nKey NPCs: \nLocations: \nEvents:"></textarea>
        <div id="preview" class="hidden w-full p-4 border border-slate-300 rounded-lg prose prose-slate max-w-none"></div>
      </div>
    </div>

    <div class="text-right text-slate-500 text-sm mt-2" id="word-count">0 words</div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const notesArea = document.getElementById('notes-area');
      const saveBtn = document.getElementById('save-btn');
      const downloadBtn = document.getElementById('download-btn');
      const clearBtn = document.getElementById('clear-btn');
      const timestampBtn = document.getElementById('timestamp-btn');
      const previewToggle = document.getElementById('preview-toggle');
      const preview = document.getElementById('preview');
      const darkToggle = document.getElementById('dark-toggle');
      const statusMessage = document.getElementById('status-message');
      const toolbarBtns = document.querySelectorAll('.toolbar-btn');
      const headingSelect = document.getElementById('heading-select');
      const wordCount = document.getElementById('word-count');

      const STORAGE_KEY = 'throom_session_notes';
      const DARK_KEY = 'throom_dark_mode';

      // Configure markdown-it for basic rendering
      const md = window.markdownit({ breaks: true, html: true });

      // --- Core Functions ---

      const saveNotes = () => {
        localStorage.setItem(STORAGE_KEY, notesArea.value);
        statusMessage.textContent = '💾 Saved!';
        setTimeout(() => statusMessage.textContent = 'Notes are automatically saved to your browser as you type.', 1500);
      };

      const loadNotes = () => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) notesArea.value = saved;
        updateWordCount();
        notesArea.focus(); // Auto-focus on load for seamless start
      };

      // FIX: Added the missing downloadNotes function
      const downloadNotes = () => {
        const text = notesArea.value;
        const filename = 'DnD_Session_Notes_' + new Date().toISOString().slice(0, 10) + '.md';

        // Create a Blob containing the text content as Markdown
        const blob = new Blob([text], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;

        // Trigger the download and clean up
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const handleClear = () => {
        const modalId = 'clear-modal';
        let modal = document.getElementById(modalId);
        if (!modal) {
            modal = document.createElement('div');
            modal.id = modalId;
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 transition-opacity duration-300 opacity-0 pointer-events-none';
            modal.innerHTML = `
                <div class="modal-content-bg bg-white p-6 rounded-lg shadow-2xl max-w-sm w-full transform transition-transform duration-300 scale-95">
                    <h3 class="text-xl font-bold mb-4 text-red-600">Confirm Clear</h3>
                    <p class="mb-6 text-slate-700 dark-mode:text-slate-300">Are you sure you want to delete ALL session notes? This action cannot be undone.</p>
                    <div class="flex justify-end gap-3">
                        <button id="cancel-clear" class="px-4 py-2 text-sm bg-slate-300 dark-mode:bg-[#444] rounded hover:bg-slate-400 dark-mode:hover:bg-[#555]">Cancel</button>
                        <button id="confirm-clear" class="px-4 py-2 text-sm bg-red-600 text-white rounded hover:bg-red-700">Yes, Clear All</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            document.getElementById('cancel-clear').addEventListener('click', () => {
                modal.classList.remove('opacity-100', 'pointer-events-auto');
                modal.querySelector('div').classList.remove('scale-100');
            });
            document.getElementById('confirm-clear').addEventListener('click', () => {
                modal.classList.remove('opacity-100', 'pointer-events-auto');
                modal.querySelector('div').classList.remove('scale-100');
                // Execute the clear logic
                localStorage.removeItem(STORAGE_KEY);
                notesArea.value = '';
                saveNotes();
                updateWordCount();
            });
        }
        
        // Apply dark mode classes to modal if needed before showing
        const isDark = document.body.classList.contains('dark-mode');
        const modalContent = modal.querySelector('.modal-content-bg');
        if (isDark) {
          modalContent.classList.add('dark-mode');
          modalContent.classList.remove('bg-white');
        } else {
          modalContent.classList.remove('dark-mode');
          modalContent.classList.add('bg-white');
        }

        // Show the modal
        setTimeout(() => {
            modal.classList.add('opacity-100', 'pointer-events-auto');
            modal.querySelector('div').classList.add('scale-100');
        }, 10);
      };
      
      const insertAtCursor = (before, after = before) => {
        const start = notesArea.selectionStart;
        const end = notesArea.selectionEnd;
        const text = notesArea.value;
        const selected = text.substring(start, end);

        // Check if the selected text already contains the formatting (for toggling)
        if (before === after && selected.startsWith(before) && selected.endsWith(after) && selected.length >= before.length * 2) {
            const strippedSelected = selected.substring(before.length, selected.length - after.length);
            notesArea.value = text.substring(0, start) + strippedSelected + text.substring(end);
            notesArea.selectionStart = start;
            notesArea.selectionEnd = start + strippedSelected.length;
        } else {
            notesArea.value = text.substring(0, start) + before + selected + after + text.substring(end);
            notesArea.selectionStart = start + before.length;
            notesArea.selectionEnd = end + before.length;
        }
        
        notesArea.focus();
        saveNotes();
        updateWordCount();
      };

      // --- Dark Mode Logic ---

      const updateDarkToggleIcon = (isDark) => {
        // Now only showing the icon on mobile, using span to hide the text
        darkToggle.innerHTML = isDark 
          ? '☀️ <span class="hidden sm:inline">Light Mode</span>' 
          : '🌙 <span class="hidden sm:inline">Dark Mode</span>';
      };

      const toggleDark = () => {
        document.body.classList.toggle('dark-mode');
        const isDark = document.body.classList.contains('dark-mode');
        localStorage.setItem(DARK_KEY, isDark ? '1' : '0');
        updateDarkToggleIcon(isDark);
      };

      const applyDarkPreference = () => {
        const isDark = localStorage.getItem(DARK_KEY) === '1';
        if (isDark) {
          document.body.classList.add('dark-mode');
        }
        updateDarkToggleIcon(isDark);
      };

      // --- Index, Tag Generation & Clickable Jumps ---

      const generateIndexAndRender = () => {
        const text = notesArea.value;
        
        // 1. Tag Extraction: Look for @Word (no spaces)
        const tagRegex = /@(\w+)/g;
        const rawTags = [...text.matchAll(tagRegex)].map(match => match[1]);
        const uniqueTags = [...new Set(rawTags)].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

        // Map to store tags and their IDs for linking
        const tagMap = new Map();
        uniqueTags.forEach(tag => {
            // Create a unique, URL-safe ID
            tagMap.set(tag, `tag-${tag.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`);
        });

        let tagHtml = '<div><h4 class="text-lg font-semibold mt-4 mb-2 border-b pb-1 border-slate-300 dark-mode:border-gray-600">Detected Tags (@)</h4>';
        if (uniqueTags.length === 0) {
            tagHtml += '<p class="text-sm italic text-gray-500 dark-mode:text-gray-400">No tags detected.</p></div>';
        } else {
            tagHtml += '<div class="flex flex-wrap gap-2 pt-2">';
            tagMap.forEach((id, tag) => {
                // Make the tag clickable in the index panel using the generated ID
                tagHtml += `
                    <a href="#${id}" class="inline-block bg-indigo-100 text-indigo-800 dark-mode:bg-indigo-900 dark-mode:text-indigo-200 px-2 py-0.5 rounded-full text-xs font-medium hover:bg-indigo-200 dark-mode:hover:bg-indigo-800 transition">
                        @${tag}
                    </a>
                `;
            });
            tagHtml += '</div></div>';
        }

        // 2. Header Extraction (Simple TOC)
        const headerRegex = /^(#+)\s(.+)$/gm;
        let headers = [];
        text.replace(headerRegex, (match, levelStr, title) => {
            const level = levelStr.length;
            headers.push({ level, title });
            return match; 
        });


        let tocHtml = '<div><h4 class="text-lg font-semibold mb-2 border-b pb-1 border-slate-300 dark-mode:border-gray-600">Table of Contents</h4>';
        if (headers.length === 0) {
            tocHtml += '<p class="text-sm italic text-gray-500 dark-mode:text-gray-400">No headings detected.</p></div>';
        } else {
            tocHtml += '<ul class="list-none p-0 space-y-1 pt-2">';
            headers.forEach(h => {
                const indent = (h.level - 1) * 1; 
                tocHtml += `<li style="padding-left: ${indent}rem;" class="text-sm text-slate-700 dark-mode:text-slate-300 overflow-hidden text-ellipsis whitespace-nowrap">${h.title}</li>`;
            });
            tocHtml += '</ul></div>';
        }

        // 3. Render Markdown
        let renderedHtml = md.render(notesArea.value);
        
        // 4. Post-Process HTML to Add Jump-To Targets (Only to the FIRST mention of each tag)
        tagMap.forEach((id, tag) => {
            const tagWithAt = `@${tag}`;
            // The target span uses the ID and highlights the tag.
            // Using a slightly stronger background here for visibility
            const targetSpan = `<span id="${id}" class="scroll-target font-bold bg-yellow-200 text-yellow-900 dark-mode:bg-yellow-700/50 p-0.5 rounded">${tagWithAt}</span>`;

            // Find the first index of the raw tag string in the rendered HTML
            const firstIndex = renderedHtml.indexOf(tagWithAt);
            
            if (firstIndex !== -1) {
                // Replace ONLY the first instance with the target span
                renderedHtml = renderedHtml.substring(0, firstIndex) + 
                               targetSpan + 
                               renderedHtml.substring(firstIndex + tagWithAt.length);
            }
        });

        // 5. Combine Index Panel and Rendered HTML
        const indexPanel = `
            <div class="mb-8 p-4 rounded-xl index-panel shadow-inner">
                ${tocHtml}
                <hr class="my-4 border-slate-200 dark-mode:border-gray-700"/>
                ${tagHtml}
            </div>
        `;

        preview.innerHTML = indexPanel + renderedHtml;
    };


      // --- Event Handlers and Helpers ---
      
      const handleKeyDown = (e) => {
        if (!(e.ctrlKey || e.metaKey)) return; 

        switch (e.key.toLowerCase()) {
          case 'b': e.preventDefault(); insertAtCursor('**'); break;
          case 'i': e.preventDefault(); insertAtCursor('*'); break;
          case 't': e.preventDefault(); insertTimestamp(); break;
          case 'p': e.preventDefault(); togglePreview(); break;
          case 's': e.preventDefault(); saveNotes(); break;
        }
      };


      const insertTimestamp = () => {
        const now = new Date().toLocaleString();
        insertAtCursor(`\n**[${now}]**\n`);
      };

      const togglePreview = () => {
        if (preview.classList.contains('hidden')) {
          // Show Preview
          generateIndexAndRender(); // Generate and render content with index/tags
          notesArea.classList.add('hidden');
          preview.classList.remove('hidden');
          previewToggle.innerHTML = '✏️ <span class="hidden sm:inline">Edit</span>';
        } else {
          // Show Editor
          preview.classList.add('hidden');
          notesArea.classList.remove('hidden');
          previewToggle.innerHTML = '👁️ <span class="hidden sm:inline">Preview</span>';
          notesArea.focus(); // Return focus to the editor
        }
      };

      const updateWordCount = () => {
        const text = notesArea.value.trim();
        const words = text ? text.split(/\s+/).filter(w => w.length > 0).length : 0;
        const chars = text.length;
        wordCount.textContent = `${words} words • ${chars} chars`;
      };
      
      // Initialize Event Listeners
      toolbarBtns.forEach(btn => btn.addEventListener('click', () => {
        const f = btn.dataset.format;
        switch(f) {
          case 'bold': insertAtCursor('**'); break;
          case 'italic': insertAtCursor('*'); break;
          case 'underline': insertAtCursor('<u>', '</u>'); break;
          case 'strike': insertAtCursor('~~'); break;
          case 'list': insertAtCursor('- ', ''); break;
          case 'quote': insertAtCursor('> ', ''); break;
          case 'code': insertAtCursor('`'); break;
          case 'divider': insertAtCursor('\n---\n', ''); break;
        }
      }));

      headingSelect.addEventListener('change', () => {
        const val = headingSelect.value;
        if (!val) return;
        const prefix = val === 'h1' ? '# ' : val === 'h2' ? '## ' : '### ';
        insertAtCursor('\n' + prefix, '\n');
        headingSelect.value = '';
      });

      notesArea.addEventListener('input', () => {
        saveNotes();
        updateWordCount();
      });

      saveBtn.addEventListener('click', saveNotes);
      clearBtn.addEventListener('click', handleClear);
      downloadBtn.addEventListener('click', downloadNotes);
      timestampBtn.addEventListener('click', insertTimestamp);
      previewToggle.addEventListener('click', togglePreview);
      darkToggle.addEventListener('click', toggleDark);

      // Register global key listener
      document.addEventListener('keydown', handleKeyDown);

      loadNotes();
      applyDarkPreference();
    });
  </script>
</body>
</html>
